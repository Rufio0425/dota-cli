#![allow(unused)]
use clap::Parser;
use ascii_image::AsciiImage;
use image::GenericImageView;

mod dota_apis;
mod ascii_image;

#[derive(Parser,Default,Debug)]
#[clap(author = "sean_aguirre", version = "1.0.0", about = "A cli application for obtaining Dota 2 information")]
struct Cli {
    request: String,

    #[clap(short, long, value_parser, default_value_t = 0)]
    hero_id: u8
}

const DEFAULT_MAX_WIDTH: u32 = 100;
const SYMBOLS: [char; 10] = [' ', '.', ':', ';', '+', 'o', 'O', '&', '@', 'â–ˆ'];

fn main() {
    let cli = Cli::parse();

    
    match cli.request.as_str() {
        "get-heros" => {
            dota_apis::get_all_heros();
        },
        "get-pudge" => {
            // dota_apis::get_pudge(); Will parse response from get_all_heros and find pudge
            let ascii_image = convert_file(&"images/pudge.png".to_string(), Some(100));
            ascii_image.print();
        },
        "get-hero-by-id" => {
            println!("Get hero {:?}", cli.hero_id);
        },
        _ => {
            println!("Improper request");
        }
    }
}

fn get_output_dimensions(img_dimensions: (u32, u32), width: u32) -> (u32, u32) {
    let ratio = img_dimensions.0 as f32 / img_dimensions.1 as f32;
    (width, (width as f32 / ratio) as u32)
}

/// Converts a given image to ascii
fn convert_file(filepath: &String, width: Option<u32>) -> AsciiImage {
    // Select the correct width for the outputed image
    let width = width.unwrap_or(DEFAULT_MAX_WIDTH);

    // Load image
    let mut image = image::open(filepath).expect("[ERROR] Unable to load the image.");
    let dimensions = image.dimensions();

    // Compute output dimensions
    let output_dimensions = get_output_dimensions(dimensions, width);

    // Create AsciiImage struct
    let mut ascii_image = AsciiImage{
        dimensions: output_dimensions,
        characters: Vec::new(),
    };

    // Convert the image to greyscale
    image = image.grayscale();
    let ratio = dimensions.0 / output_dimensions.0; // an image of 1000w converted to 100w => ratio = 10

    for x in 0..output_dimensions.0 {
        for y in 0..output_dimensions.1 {
            let pixel = image.get_pixel(x * ratio, y * ratio);
            let brightness = (pixel[0] as f64 + pixel[1] as f64 + pixel[2] as f64) / 3 as f64;

            // This code was generated by autopilot. Thank you autopilot, very cool.
            ascii_image.characters.push(SYMBOLS[(brightness / (255 as f64 / (SYMBOLS.len() - 1) as f64)) as usize]);
        }
    }

    ascii_image
}

#[test]
fn test_get_output_dimensions() {
    assert_eq!(
        get_output_dimensions(
            (100, 100), 
            100
        ), 
        (100, 100)
    );
}